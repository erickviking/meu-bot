// bot.js - Secret√°ria NEPQ com Redis Persistente
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const OpenAI = require('openai');
const redis = require('redis');

const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
const fs = require('fs');

const app = express();
app.use(bodyParser.json());

// ---- CONTROLE DE CUSTOS MAIS RIGOROSO ---------------------------------------
let dailyTokenCount = 0;
let dailyRequestCount = 0;
let hourlyTokenCount = 0;
let hourlyRequestCount = 0;

// Limites mais conservadores
const MAX_DAILY_TOKENS = 50000;
const MAX_DAILY_REQUESTS = 2000;
const MAX_HOURLY_TOKENS = 5000;
const MAX_HOURLY_REQUESTS = 200;

const emergencyPhones = new Set();

// Reset di√°rio dos contadores
setInterval(() => {
  dailyTokenCount = 0;
  dailyRequestCount = 0;
  console.log('üîÑ Contadores di√°rios resetados');
}, 24 * 60 * 60 * 1000);

// Reset hor√°rio dos contadores
setInterval(() => {
  hourlyTokenCount = 0;
  hourlyRequestCount = 0;
  console.log('üîÑ Contadores hor√°rios resetados');
}, 60 * 60 * 1000);

// ---- SESSION MANAGER COM REDIS PERSISTENTE ----------------------------------
class SessionManager {
  constructor() {
    // Conecta ao Redis
    this.client = redis.createClient({
      url: process.env.REDIS_URL || 'redis://localhost:6379'
    });
    
    this.client.on('error', (err) => {
      console.error('‚ùå Redis error:', err.message);
      this.fallbackToMemory = true;
    });
    
    this.client.on('connect', () => {
      console.log('‚úÖ Redis conectado - Sessions persistentes ativas');
      this.fallbackToMemory = false;
    });
    
    // Fallback para memory se Redis falhar
    this.memoryCache = new Map();
    this.memoryRateLimit = new Map();
    this.fallbackToMemory = false;
    
    // Conecta
    this.client.connect().catch(() => {
      console.warn('‚ö†Ô∏è Redis indispon√≠vel - usando memory fallback');
      this.fallbackToMemory = true;
    });
  }

  // Busca session com fallback autom√°tico
  async getSession(phone) {
    try {
      if (this.fallbackToMemory) {
        return this.getSessionFromMemory(phone);
      }

      // Tenta buscar no Redis primeiro
      const sessionData = await this.client.get(`session:${phone}`);
      
      if (sessionData) {
        const session = JSON.parse(sessionData);
        // Atualiza √∫ltima atividade
        session.lastActivity = Date.now();
        await this.saveSession(phone, session);
        return session;
      }
      
      // Se n√£o existe, cria nova
      const newSession = this.createNewSession();
      await this.saveSession(phone, newSession);
      return newSession;
      
    } catch (error) {
      console.error('‚ö†Ô∏è Redis falhou, usando memory fallback:', error.message);
      this.fallbackToMemory = true;
      return this.getSessionFromMemory(phone);
    }
  }

  // Salva session com TTL
  async saveSession(phone, session) {
    try {
      if (this.fallbackToMemory) {
        this.memoryCache.set(phone, session);
        return;
      }

      // Salva no Redis com TTL de 2 horas
      await this.client.setEx(
        `session:${phone}`, 
        7200, // 2 horas em segundos
        JSON.stringify(session)
      );
      
    } catch (error) {
      console.error('‚ö†Ô∏è Erro ao salvar session, usando memory:', error.message);
      this.memoryCache.set(phone, session);
    }
  }

  // Rate limiting persistente
  async isRateLimited(phone) {
    try {
      if (this.fallbackToMemory) {
        return this.isRateLimitedMemory(phone);
      }

      const now = Date.now();
      const key = `rate:${phone}`;
      
      // Busca requests recentes
      const requests = await this.client.lRange(key, 0, -1);
      const recentRequests = requests
        .map(Number)
        .filter(time => now - time < 60000); // √öltimo minuto
      
      // Diferentes limites baseado no hist√≥rico do usu√°rio
      let maxRequests = 10;
      if (recentRequests.length === 0) maxRequests = 5; // Novos usu√°rios
      
      // Busca session para verificar hist√≥rico
      const session = await this.getSession(phone);
      if (session && session.conversationHistory && session.conversationHistory.length > 20) {
        maxRequests = 15; // Usu√°rios ativos
      }
      
      if (recentRequests.length >= maxRequests) {
        return true;
      }
      
      // Adiciona nova request e limpa antigas
      await this.client.lPush(key, now.toString());
      await this.client.lTrim(key, 0, maxRequests - 1); // Mant√©m s√≥ as √∫ltimas
      await this.client.expire(key, 60); // Expira em 1 minuto
      
      return false;
      
    } catch (error) {
      console.error('‚ö†Ô∏è Rate limiting falhou, usando memory:', error.message);
      return this.isRateLimitedMemory(phone);
    }
  }

  // Fallback para memory
  getSessionFromMemory(phone) {
    if (!this.memoryCache.has(phone)) {
      this.memoryCache.set(phone, this.createNewSession());
    }
    
    const session = this.memoryCache.get(phone);
    session.lastActivity = Date.now();
    return session;
  }

  isRateLimitedMemory(phone) {
    const now = Date.now();
    const userRequests = this.memoryRateLimit.get(phone) || [];
    
    const recentRequests = userRequests.filter(time => now - time < 60000);
    
    let maxRequests = 10;
    if (recentRequests.length === 0) maxRequests = 5;
    
    const session = this.memoryCache.get(phone);
    if (session && session.conversationHistory && session.conversationHistory.length > 20) {
      maxRequests = 15;
    }
    
    if (recentRequests.length >= maxRequests) {
      return true;
    }
    
    recentRequests.push(now);
    this.memoryRateLimit.set(phone, recentRequests);
    return false;
  }

  // Cria nova session padr√£o
  createNewSession() {
    return {
      stage: 'start',
      firstName: null,
      askedName: false,
      lastIntent: '',
      problemContext: null,
      duration: null,
      worsening: null,
      triedSolutions: null,
      impact: null,
      desiredOutcome: null,
      repeatCount: 0,
      conversationHistory: [],
      lastActivity: Date.now(),
      requestCount: 0,
      timezone: 'America/Sao_Paulo',
      createdAt: Date.now()
    };
  }

  // Limpa sessions antigas
  async cleanup() {
    try {
      if (this.fallbackToMemory) {
        const TWO_HOURS = 2 * 60 * 60 * 1000;
        const now = Date.now();
        let cleaned = 0;
        
        for (const [phone, session] of this.memoryCache.entries()) {
          if (!session.lastActivity || (now - session.lastActivity) > TWO_HOURS) {
            this.memoryCache.delete(phone);
            cleaned++;
          }
        }
        
        if (cleaned > 0) {
          console.log(`üßπ Memory cleanup: ${cleaned} sess√µes removidas`);
        }
        return;
      }

      // Redis faz cleanup autom√°tico via TTL
      const keys = await this.client.keys('session:*');
      let activeCount = 0;
      
      for (const key of keys) {
        const ttl = await this.client.ttl(key);
        if (ttl > 0) activeCount++;
      }
      
      console.log(`üìä Redis sessions ativas: ${activeCount}`);
      
    } catch (error) {
      console.error('‚ö†Ô∏è Erro no cleanup:', error.message);
    }
  }

  // Estat√≠sticas
  async getStats() {
    try {
      if (this.fallbackToMemory) {
        return {
          activeSessions: this.memoryCache.size,
          activeRateLimits: this.memoryRateLimit.size,
          storage: 'memory',
          redis: false
        };
      }

      const sessionKeys = await this.client.keys('session:*');
      const rateKeys = await this.client.keys('rate:*');
      
      return {
        activeSessions: sessionKeys.length,
        activeRateLimits: rateKeys.length,
        storage: 'redis',
        redis: true
      };
      
    } catch (error) {
      return {
        activeSessions: this.memoryCache.size,
        activeRateLimits: this.memoryRateLimit.size,
        storage: 'memory-fallback',
        redis: false,
        error: error.message
      };
    }
  }

  // Graceful shutdown
  async close() {
    try {
      if (!this.fallbackToMemory) {
        await this.client.disconnect();
        console.log('‚úÖ Redis desconectado gracefully');
      }
    } catch (error) {
      console.error('‚ö†Ô∏è Erro ao desconectar Redis:', error.message);
    }
  }
}

// Inicializa o session manager
const sessionManager = new SessionManager();

// Substitui fun√ß√£o getSession original por vers√£o Redis
async function getSession(phone) {
  const session = await sessionManager.getSession(phone);
  return session;
}

// Substitui fun√ß√£o isRateLimited original por vers√£o Redis  
async function isRateLimited(phone) {
  return await sessionManager.isRateLimited(phone);
}

// Fun√ß√£o para salvar session ap√≥s modifica√ß√µes
async function saveSession(phone, session) {
  await sessionManager.saveSession(phone, session);
}

// Cleanup usando session manager
async function cleanupOldSessions() {
  await sessionManager.cleanup();
}

// Executa limpeza a cada 30 minutos
setInterval(cleanupOldSessions, 30 * 60 * 1000);

// ---- CONFIGURA√á√ÉO DA OPENAI -------------------------------------------------
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// ---- DETEC√á√ÉO DE EMERG√äNCIAS M√âDICAS MELHORADA -----------------------------
function isEmergency(message) {
  const emergencyKeywords = [
    // Card√≠acas
    'infarto', 'infarte', 'ataque cardiaco', 'ataque card√≠aco', 'peito d√≥i muito', 'dor no peito forte',
    'parada card√≠aca', 'parada cardiaca', 'cora√ß√£o parou',
    
    // Respirat√≥rias
    'n√£o consigo respirar', 'nao consigo respirar', 'falta de ar grave', 'sufocando',
    'engasgado', 'engasgada', 'asfixia',
    
    // Neurol√≥gicas
    'avc', 'derrame', 'convuls√£o', 'convulsao', 'ataque epil√©tico', 'epileptico',
    'desmaiei', 'desmaiou', 'inconsciente', 'perdeu consciencia',
    
    // Traumas
    'acidente', 'atropelado', 'fratura exposta', 'sangramento grave', 'muito sangue',
    'osso quebrado', 'quebrei o osso', 'sangramento',
    
    // Intoxica√ß√µes
    'overdose', 'envenenamento', 'intoxica√ß√£o', 'intoxicacao', 'veneno',
    
    // Emerg√™ncia geral
    'emergencia', 'emerg√™ncia', 'urgencia grave', 'urg√™ncia grave', 'socorro',
    'samu', '192', '193', '190', 'ambulancia', 'ambul√¢ncia',
    
    // Suic√≠dio
    'vou me matar', 'quero morrer', 'suicidio', 'suic√≠dio', 'me matar', 'vou morrer', 'morrer',
    
    // Dor extrema
    'dor insuport√°vel', 'dor insuportavel', 'n√£o aguento mais', 'nao aguento mais'
  ];
  
  const msg = message.toLowerCase().trim();
  return emergencyKeywords.some(keyword => msg.includes(keyword));
}

function getEmergencyResponse(firstName) {
  const name = firstName || 'amigo(a)';
  return `üö® ${name}, se voc√™ est√° tendo uma emerg√™ncia m√©dica, por favor:

LIGUE IMEDIATAMENTE:
üöë SAMU: 192
üöí Bombeiros: 193  
üöì Emerg√™ncia: 190

V√° ao pronto-socorro mais pr√≥ximo. N√ÉO ESPERE!

Para consultas n√£o urgentes, retome contato quando estiver seguro.

O Dr. Quelson n√£o atende emerg√™ncias pelo WhatsApp.`;
}

// ---- RATE LIMITING MELHORADO COM REDIS --------------------------------------
// Agora usa sessionManager.isRateLimited() que j√° foi implementado acima

// ---- CONTROLE DE CUSTOS MAIS RIGOROSO ---------------------------------------
function checkCostLimits() {
  // Verifica limites hor√°rios primeiro
  if (hourlyTokenCount > MAX_HOURLY_TOKENS) {
    throw new Error(`Limite HOR√ÅRIO de tokens excedido: ${hourlyTokenCount}/${MAX_HOURLY_TOKENS}`);
  }
  
  if (hourlyRequestCount > MAX_HOURLY_REQUESTS) {
    throw new Error(`Limite HOR√ÅRIO de requests excedido: ${hourlyRequestCount}/${MAX_HOURLY_REQUESTS}`);
  }
  
  // Depois verifica limites di√°rios
  if (dailyTokenCount > MAX_DAILY_TOKENS) {
    throw new Error(`Limite DI√ÅRIO de tokens excedido: ${dailyTokenCount}/${MAX_DAILY_TOKENS}`);
  }
  
  if (dailyRequestCount > MAX_DAILY_REQUESTS) {
    throw new Error(`Limite DI√ÅRIO de requests excedido: ${dailyRequestCount}/${MAX_DAILY_REQUESTS}`);
  }
}

// ---- COMPRESS√ÉO DE CONTEXTO --------------------------------------------------
function compressContext(history) {
  if (!history || history.length <= 30) return history;
  
  // Mant√©m primeiras 10 e √∫ltimas 20 mensagens para economizar tokens
  const compressed = [
    ...history.slice(0, 10),
    `... [${history.length - 30} mensagens resumidas] ...`,
    ...history.slice(-20)
  ];
  
  return compressed;
}

// ---- FUN√á√ïES AUXILIARES BLINDADAS -------------------------------------------
function extractFirstName(text) {
  if (!text || typeof text !== 'string') return 'Paciente';
  
  const cleaned = text.trim().toLowerCase();
  
  const patterns = [
    /(?:aqui (?:√©|eh) |sou (?:a |o )?|me chamo |meu nome (?:√©|eh) )(.+)/,
    /(?:√©|eh) (?:a |o )?(.+)/,
    /^(.+)$/
  ];
  
  for (const pattern of patterns) {
    const match = cleaned.match(pattern);
    if (match) {
      const name = match[1].trim().split(' ')[0];
      // Sanitiza e capitaliza
      const safeName = name.replace(/[^a-z√°√†√£√¢√©√™√≠√≥√¥√µ√∫√ß]/gi, '');
      return safeName.charAt(0).toUpperCase() + safeName.slice(1);
    }
  }
  
  return text.trim().split(' ')[0].replace(/[^a-z√°√†√£√¢√©√™√≠√≥√¥√µ√∫√ß]/gi, '') || 'Paciente';
}

function containsFirstNameOnly(text) {
  if (!text || typeof text !== 'string') return false;
  
  const cleaned = text.trim().toLowerCase();
  
  const namePatterns = [
    /(?:aqui (?:√©|eh) |sou (?:a |o )?|me chamo |meu nome (?:√©|eh) )/,
    /^[a-z√°√†√£√¢√©√™√≠√≥√¥√µ√∫√ß\s]+$/i
  ];
  
  if (namePatterns.some(pattern => pattern.test(cleaned))) {
    return true;
  }
  
  if (cleaned.length < 2 || cleaned.length > 50 || /\d|[!@#$%^&*()_+=\[\]{}|;':",./<>?]/.test(cleaned)) {
    return false;
  }
  
  return true;
}

// ---- HOR√ÅRIO INTELIGENTE (TIMEZONE AWARE) -----------------------------------
function getCurrentGreeting() {
  const now = new Date();
  // For√ßa timezone do Brasil
  const brasilTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Sao_Paulo"}));
  const hour = brasilTime.getHours();
  
  if (hour >= 5 && hour < 12) {
    return 'Bom dia!';
  } else if (hour >= 12 && hour < 18) {
    return 'Boa tarde!';
  } else {
    return 'Boa noite!';
  }
}

// ---- FALLBACK CONTEXTUAL ----------------------------------------------------
function detectIntentFallbackContextual(message, stage, session) {
  const msg = message.toLowerCase().trim();
  
  // Emerg√™ncia sempre tem prioridade
  if (isEmergency(msg)) return 'emergencia';
  
  // CONTEXTO: Se j√° mencionou agendamento antes
  const wantedScheduling = session.problemContext === 'agendamento_direto' || 
                          (session.conversationHistory || []).some(h => 
                            h.includes('agendar') || h.includes('marcar') || h.includes('consulta')
                          );
  
  // Se j√° quer agendar e pergunta pre√ßo = valores
  if (wantedScheduling && (msg.includes('valor') || msg.includes('pre√ßo') || msg.includes('custa') || msg.includes('quanto'))) {
    return 'valores';
  }
  
  // Detec√ß√£o de confus√£o
  if (msg.includes('o que') || msg.includes('sente o que') || msg === 'que' || msg === 'o qu√™' || msg === 'o que?') {
    return 'confusao';
  }
  
  // Exame de rotina
  if (msg.includes('rotina') || msg.includes('checkup') || msg.includes('preventiv') || msg.includes('check up')) {
    return 'exame_rotina';
  }
  
  // Procedimentos
  if (msg.includes('endoscopia') || msg.includes('colonoscopia') || msg.includes('exame') || msg.includes('procedimento')) {
    return 'procedimento';
  }
  
  // Resto das categorias
  if (msg.includes('agendar') || msg.includes('marcar') || msg.includes('consulta')) return 'agendar';
  if (msg.includes('valor') || msg.includes('pre√ßo') || msg.includes('custa') || msg.includes('quanto')) return 'valores';
  if (msg.includes('conv√™nio') || msg.includes('convenio') || msg.includes('plano') || msg.includes('unimed')) return 'convenio';
  if (msg.includes('hor√°rio') || msg.includes('horario') || msg.includes('funciona') || msg.includes('atende')) return 'horarios';
  if (msg.includes('dor') || msg.includes('sintoma') || msg.includes('problema') || msg.includes('sinto')) return 'sintomas';
  if (msg.includes('sim') || msg.includes('ok') || msg.includes('tudo bem') || msg.includes('pode')) return 'positiva';
  if (msg.includes('n√£o') || msg.includes('nao') || msg.includes('nunca') || msg.includes('jamais')) return 'negativa';
  if (msg.includes('depende') || msg.includes('preciso saber') || msg.includes('antes')) return 'condicional';
  if (msg.includes('oi') || msg.includes('ol√°') || msg.includes('ola') || msg.includes('tchau')) return 'saudacao';
  
  return 'outra';
}

// ---- CLASSIFICADOR COM CONTEXTO INTELIGENTE ----------------------------------
async function detectIntent(message, stage, session, retries = 2) {
  try {
    checkCostLimits();
    
    // Monta contexto RICO da conversa
    const conversationContext = `
CONTEXTO COMPLETO DA CONVERSA:
- Nome do paciente: ${session.firstName || 'N/A'}
- Est√°gio atual: ${stage}
- √öltimo problema mencionado: ${session.problemContext || 'Nenhum'}
- √öltima inten√ß√£o: ${session.lastIntent || 'N/A'}
- Hist√≥rico recente: ${(session.conversationHistory || []).slice(-10).join(' | ')}

SITUA√á√ÉO ATUAL:
O paciente ${session.firstName || 'algu√©m'} est√° conversando com a secret√°ria do Dr. Quelson (gastroenterologista).
${session.problemContext ? `Contexto: O paciente mencionou querer ${session.problemContext}.` : ''}
${stage === 'problema' ? 'A secret√°ria est√° tentando entender qual o problema de sa√∫de do paciente.' : ''}
${stage === 'situacao' ? 'A secret√°ria est√° entendendo o motivo do contato.' : ''}

IMPORTANTE: Analise a mensagem considerando TODO o contexto acima, n√£o apenas a mensagem isolada.
`;

    const prompt = `${conversationContext}

Baseado no CONTEXTO COMPLETO acima, analise a inten√ß√£o da mensagem atual:

CATEGORIAS:
- emergencia: situa√ß√£o de emerg√™ncia m√©dica
- agendar: quer marcar consulta (incluindo quando j√° mencionou antes)
- valores: pergunta sobre pre√ßo, valor, quanto custa
- sintomas: descreve problemas de sa√∫de espec√≠ficos
- convenio: pergunta sobre planos de sa√∫de
- horarios: quer saber hor√°rios de funcionamento
- positiva: concorda, aceita, quer continuar
- negativa: recusa, n√£o quer
- condicional: "depende", condi√ß√µes
- confusao: n√£o entendeu algo, pergunta "o que?"
- saudacao: cumprimentos
- exame_rotina: menciona exame preventivo, checkup
- procedimento: pergunta sobre procedimentos espec√≠ficos
- outra: outras respostas

MENSAGEM ATUAL: "${message}"

INSTRU√á√ïES:
1. Considere o CONTEXTO COMPLETO, n√£o apenas a mensagem isolada
2. Se o paciente j√° disse que quer agendar antes, perguntas sobre pre√ßo s√£o categoria "valores"
3. Se pergunta "o que?" ou similar, √© provavelmente "confusao"
4. Se menciona exame de rotina ou preventivo, √© "exame_rotina"

Responda APENAS com a categoria mais apropriada:`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 15,
      temperature: 0.1, // Mais determin√≠stico
    });

    const tokens = response.usage?.total_tokens || 15;
    dailyTokenCount += tokens;
    hourlyTokenCount += tokens;
    dailyRequestCount++;
    hourlyRequestCount++;
    
    const result = response.choices[0].message.content.trim().toLowerCase();
    
    // Valida resultado
    const validCategories = ['emergencia', 'agendar', 'valores', 'sintomas', 'convenio', 'horarios', 'positiva', 'negativa', 'condicional', 'saudacao', 'confusao', 'exame_rotina', 'procedimento', 'outra'];
    if (!validCategories.includes(result)) {
      console.warn(`‚ö†Ô∏è IA retornou categoria inv√°lida: ${result}, usando fallback`);
      return detectIntentFallbackContextual(message, stage, session);
    }
    
    return result;
    
  } catch (error) {
    console.error(`‚ö†Ô∏è OpenAI falhou (tentativa ${3-retries}):`, error.message);
    
    if (retries > 0) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      return detectIntent(message, stage, session, retries - 1);
    }
    
    return detectIntentFallbackContextual(message, stage, session);
  }
}

// ---- RESPOSTAS VARIADAS PARA NATURALIDADE -----------------------------------
function getRandomResponse(responses) {
  if (!responses || !Array.isArray(responses) || responses.length === 0) {
    return 'Desculpe, estou com dificuldades t√©cnicas. Como posso te ajudar?';
  }
  return responses[Math.floor(Math.random() * responses.length)];
}

// ---- GERA√á√ÉO DE RESPOSTA BLINDADA -------------------------------------------
async function generateReply(session, from, message) {
  try {
    // Previne loops infinitos
    if (session.repeatCount > 5) {
      return `${session.firstName || 'Paciente'}, percebo que estamos tendo dificuldades na comunica√ß√£o. Que tal ligar diretamente para (11) 99999-9999? Assim posso te ajudar melhor! üòä`;
    }
    
    // Previne mensagens muito longas
    if (message.length > 500) {
      return `${session.firstName || 'Paciente'}, sua mensagem √© um pouco longa. Pode resumir em poucas palavras o que precisa? Assim consigo te atender melhor! üòä`;
    }
    
    // Adiciona mensagem ao hist√≥rico
    if (!session.conversationHistory) {
      session.conversationHistory = [];
    }
    session.conversationHistory.push(`Paciente: ${message}`);
    
    // Mant√©m √∫ltimas 100 mensagens (com compress√£o inteligente)
    if (session.conversationHistory.length > 100) {
      session.conversationHistory = session.conversationHistory.slice(-100);
    }

    const intent = await detectIntent(message, session.stage, session);

    // Detecta loops de repeti√ß√£o
    if (intent === session.lastIntent) {
      session.repeatCount += 1;
    } else {
      session.repeatCount = 0;
    }
    session.lastIntent = intent;

    // EMERG√äNCIA tem prioridade m√°xima
    if (intent === 'emergencia') {
      const emergencyReply = getEmergencyResponse(session.firstName);
      emergencyPhones.add(from); // Marca para n√£o repetir
      session.conversationHistory.push(`Bot: ${emergencyReply}`);
      return emergencyReply;
    }

    // Captura de nome com sauda√ß√£o calorosa
    if (!session.firstName) {
      if (!session.askedName) {
        session.askedName = true;
        const saudacao = getCurrentGreeting();
        
        const saudacoes = [
          `${saudacao} Voc√™ entrou em contato com o Consult√≥rio do Dr. Quelson, especialista em Gastroenterologia. Com quem eu tenho o prazer de falar? üòä`,
          `${saudacao} Aqui √© do consult√≥rio do Dr. Quelson. √â um prazer falar com voc√™! Qual seu nome?`,
          `${saudacao} Voc√™ est√° falando com a secret√°ria do Dr. Quelson. Como posso te chamar?`
        ];
        const reply = getRandomResponse(saudacoes);
        session.conversationHistory.push(`Bot: ${reply}`);
        return reply;
      }
      
      if (containsFirstNameOnly(message)) {
        session.firstName = extractFirstName(message);
        session.stage = 'situacao';
        
        const situacaoResponses = [
          `Oi, ${session.firstName}! Tudo bem? Como posso te ajudar hoje? O que te motivou a procurar o Dr. Quelson? üß°`,
          `√â um prazer falar com voc√™, ${session.firstName}! üòä Pode me contar um pouquinho o que est√° te incomodando? Assim consigo te orientar melhor üôè`,
          `Seja bem-vindo(a), ${session.firstName}! Queria te escutar um pouquinho... Pode me contar o que tem te preocupado? √Äs vezes s√≥ isso j√° alivia üí¨`
        ];
        const reply = getRandomResponse(situacaoResponses);
        session.conversationHistory.push(`Bot: ${reply}`);
        return reply;
      } else {
        const reply = 'Desculpe, n√£o consegui entender seu nome. Pode me dizer apenas seu primeiro nome, por favor?';
        session.conversationHistory.push(`Bot: ${reply}`);
        return reply;
      }
    }

    let reply = '';

    // Fluxo NEPQ humanizado baseado no est√°gio
    switch (session.stage) {
      case 'situacao':
        // üü¢ SITUA√á√ÉO - Entendendo o contexto com empatia
        if (intent === 'agendar') {
          session.stage = 'problema';
          session.problemContext = 'agendamento_direto';
          reply = `Entendo, ${session.firstName}. Para eu conseguir o melhor hor√°rio e preparar o Dr. Quelson para te atender bem, pode me contar o que est√° te incomodando? üôè`;
        } 
        else { else if (intent === 'convenio') {
          reply = `${session.firstName}, aqui o Dr. Quelson atende particular, mas posso te dizer uma coisa? Muita gente que vem aqui j√° passou por v√°rios m√©dicos do conv√™nio... e depois fala que valeu cada centavo investir numa consulta onde realmente se sentiram ouvidas. 

A consulta √© R$ 400,00. Pode me contar qual o motivo que te trouxe aqui? Assim posso te explicar se √© o tipo de caso que o Dr. Quelson pode te ajudar üòä`;
        } else if (intent === 'condicional') {
          reply = `${session.firstName}, entendo que voc√™ precisa se planejar! Aqui √© atendimento particular (R$ 400,00). Mas me conta: o que est√° te preocupando? Assim posso te orientar se vale a pena investir numa consulta especializada üòä`;
        } else if (intent === 'valores') {
          reply = `${session.firstName}, a consulta √© R$ 400,00. Mas antes de te explicar como funciona, me ajuda com uma coisa? O que exatamente est√° te preocupando? Assim posso te explicar direitinho como o Dr. Quelson pode te ajudar üòä`;
        } else if (intent === 'sintomas') {
          session.stage = 'problema';
          session.problemContext = message;
          const problemResponses = [
            `Nossa, ${session.firstName}... deve ser bem dif√≠cil mesmo üòî E isso tem te incomodado mais em qual parte do dia? De manh√£, √† noite...?`,
            `Poxa, ${session.firstName}, entendo... H√° quanto tempo est√° assim?`,
            `Nossa, ${session.firstName}... Deve ser bem preocupante. Me conta, h√° quanto tempo voc√™ sente isso?`
          ];
          reply = getRandomResponse(problemResponses);
        } else if (intent === 'urgencia') {
          session.stage = 'problema';
          reply = `${session.firstName}, entendo sua urg√™ncia. Para eu conseguir o melhor hor√°rio para voc√™, pode me contar rapidinho o que est√° acontecendo?`;
        // NOVO: Trata exame de rotina
        else if (intent === 'exame_rotina') {
          session.stage = 'fechamento';
          session.problemContext = 'exame_rotina';
          reply = `Perfeito, ${session.firstName}! Exame de rotina √© muito importante. O Dr. Quelson vai fazer uma avalia√ß√£o completa.

A consulta √© R$ 400,00 e dura 60 minutos. Ele far√° uma anamnese detalhada e, se necess√°rio, solicitar√° exames complementares.

O Dr. Quelson atende de segunda a sexta, das 8h √†s 18h, e s√°bados pela manh√£. 

Voc√™ gostaria de agendar ainda essa semana? üìÖ`;
        }
          reply = `${session.firstName}, pode me contar um pouquinho do que est√° te incomodando? Como posso te ajudar melhor com isso que voc√™ est√° sentindo? üí¨`;
        }
        break;

      case 'problema':
        // üî¥ PROBLEMA - Criando consci√™ncia da dor
        
        // NOVO: Se pergunta sobre valores, responde diretamente
        if (intent === 'valores') {
          reply = `${session.firstName}, a consulta √© R$ 400,00. Mas antes de agendarmos, me ajuda com uma coisa? O que exatamente est√° te incomodando? Assim posso te explicar direitinho como o Dr. Quelson pode te ajudar üòä`;
        }
        // NOVO: Se pergunta sobre conv√™nio, responde diretamente  
        else if (intent === 'convenio') {
          reply = `${session.firstName}, aqui o Dr. Quelson atende particular (R$ 400,00). Pode me contar qual o motivo da consulta? Assim posso te orientar melhor.`;
        }
        // NOVO: Se pergunta "o que", "sente o que", clarifica
        else if (intent === 'confusao' || (intent === 'outra' && (message.toLowerCase().includes('o que') || message.toLowerCase().includes('sente o que')))) {
          reply = `Desculpe a confus√£o, ${session.firstName}! Voc√™ me disse que quer marcar uma consulta. Pode me contar qual o motivo? Por exemplo: algum desconforto, dor, exame de rotina... Assim o Dr. Quelson pode se preparar melhor para te atender! üòä`;
          session.stage = 'situacao'; // Volta para situa√ß√£o
        }
        // Fluxo normal de problema
        else if (intent === 'duracao' || intent === 'sintomas') {
          if (!session.duration) {
            session.duration = message;
            const worseningQuestions = [
              `E isso tem piorado com o tempo ou mant√©m do mesmo jeito, ${session.firstName}?`,
              `J√° aconteceu de isso atrapalhar algum momento importante seu? Algum evento, trabalho, sono...?`,
              `Voc√™ sente que tem ficado mais intenso ultimamente?`
            ];
            reply = getRandomResponse(worseningQuestions);
          } else if (!session.worsening) {
            session.worsening = message;
            const solutionQuestions = [
              `Voc√™ j√° passou com algum m√©dico por isso antes? Sentiu que te ajudaram de verdade?`,
              `J√° tentou algum tratamento ou medica√ß√£o para isso?`,
              `E voc√™ j√° tentou resolver de alguma forma? Algum tratamento, medica√ß√£o ou mudan√ßa na alimenta√ß√£o?`
            ];
            reply = getRandomResponse(solutionQuestions);
          } else if (!session.triedSolutions) {
            session.triedSolutions = message;
            session.stage = 'implicacao';
            const implicationStarters = [
              `Entendo, ${session.firstName}... Voc√™ sente que isso tem afetado sua rotina?`,
              `Puxa, ${session.firstName}... E isso j√° atrapalhou seu sono ou alimenta√ß√£o?`,
              `Nossa... J√° parou pra pensar no quanto isso te desgasta emocionalmente? üòû`
            ];
            reply = getRandomResponse(implicationStarters);
          }
        } 
        // Se n√£o tem problema definido ainda
        else {
          // Se est√° repetindo perguntas, muda abordagem
          if (session.repeatCount > 2) {
            reply = `${session.firstName}, vou reformular: voc√™ quer agendar uma consulta. √â para algum problema espec√≠fico, exame de rotina, ou consulta preventiva? Assim posso te orientar melhor! üòä`;
            session.stage = 'situacao'; // Volta para situa√ß√£o
          } else {
            const problemQuestions = [
              `${session.firstName}, me conta: o que te trouxe aqui hoje?`,
              `Qual o motivo da consulta, ${session.firstName}?`,
              `Pode me falar sobre o que est√° te preocupando?`
            ];
            reply = getRandomResponse(problemQuestions);
          }
        }

      case 'implicacao':
        // üü† IMPLICA√á√ÉO - Aumentando a urg√™ncia com cuidado
        if (intent === 'impacto' || intent === 'positiva') {
          if (!session.impact) {
            session.impact = message;
            session.stage = 'solucao';
            const futureQuestions = [
              `${session.firstName}, se isso continuar mais algumas semanas ou meses... como imagina que vai estar sua vida?`,
              `O que mais te preocupa nisso tudo hoje, ${session.firstName}?`,
              `Tem algo que voc√™ sente que est√° deixando de viver por causa disso?`
            ];
            reply = getRandomResponse(futureQuestions);
          }
        } else {
          const implicationQuestions = [
            `E se eu te perguntasse: isso j√° est√° afetando seu dia a dia? Sua alimenta√ß√£o, sono, ou sua tranquilidade em geral?`,
            `Voc√™ sente que isso tem afetado sua rotina, ${session.firstName}?`,
            `J√° parou pra pensar no quanto isso te desgasta emocionalmente? üòû`
          ];
          reply = getRandomResponse(implicationQuestions);
        }
        break;

      case 'solucao':
        // üü° SOLU√á√ÉO - Fazendo visualizar a melhora
        if (intent === 'desejo_melhora' || intent === 'positiva') {
          session.desiredOutcome = message;
          session.stage = 'fechamento';
          const visualizationResponses = [
            `${session.firstName}, imagina s√≥ se isso j√° estivesse resolvido... o que voc√™ faria diferente no seu dia? üåû`,
            `E se voc√™ come√ßasse a melhorar em algumas semanas... qual seria a primeira coisa que voc√™ iria comemorar? ‚ú®`,
            `Como seria sua vida se esse problema n√£o existisse mais, ${session.firstName}? ‚ú®`
          ];
          reply = getRandomResponse(visualizationResponses);
        } else {
          const solutionQuestions = [
            `${session.firstName}, imagina s√≥ se isso j√° estivesse resolvido... o que voc√™ faria diferente no seu dia? üåû`,
            `E se voc√™ tivesse um plano claro pra resolver isso, montado por algu√©m que realmente te escuta... o quanto isso te traria mais paz?`,
            `Como seria sua vida se esse problema n√£o existisse mais? ‚ú®`
          ];
          reply = getRandomResponse(solutionQuestions);
        }
        break;

      case 'fechamento':
        // üü£ FECHAMENTO - Conduzindo com autoridade e prova social
        if (intent === 'agendar' || intent === 'positiva' || intent === 'horarios') {
          const agendamentoResponses = [
            `Entendi, ${session.firstName}. E olha, o Dr. Quelson tem atendido muitas pessoas com esse mesmo tipo de sintoma. O que elas mais dizem quando saem da consulta √© que, pela primeira vez, sentiram que algu√©m realmente parou pra escutar, investigar a fundo e explicar com clareza o que est√° acontecendo ‚Äî sem pressa, sem superficialidade.

Te falo isso porque tem muito paciente que j√° passou por 2, 3 m√©dicos do plano, tomou v√°rios rem√©dios, mas o problema sempre volta‚Ä¶ e quando chegam aqui, descobrem que estavam tratando o efeito, n√£o a causa.

A consulta √© R$ 400,00 e dura 60 minutos. O Dr. Quelson atende de segunda a sexta, das 8h √†s 18h, e s√°bados pela manh√£. 

Voc√™ gostaria de agendar ainda essa semana para j√° come√ßar esse processo? üìÖ`,

            `${session.firstName}, que bom que voc√™ est√° buscando ajuda agora ‚Äî porque quanto mais cedo voc√™ entende o que est√° acontecendo, mais f√°cil √© tratar de forma certa.

O Dr. Quelson √© especialista em gastroenterologia, e ele costuma ser o primeiro m√©dico que muitos pacientes procuram justamente por isso: ele escuta com calma, investiga a fundo e j√° come√ßa com um plano claro, sem perder tempo com tentativa e erro.

A consulta √© R$ 400,00, 60 minutos onde ele realmente te escuta. Quem passa com ele geralmente diz que sai mais tranquilo por entender de verdade o que est√° acontecendo.

Posso ver aqui o melhor hor√°rio para voc√™... Pode ser essa semana ainda? üìÖ`
          ];
          reply = getRandomResponse(agendamentoResponses);
        } else if (intent === 'valores') {
          reply = `${session.firstName}, a consulta √© R$ 400,00, e olha... vale cada centavo. √â uma consulta de 60 minutos onde o Dr. Quelson realmente te escuta e investiga a fundo. Muitos pacientes j√° me disseram: "Se soubesse que era assim, teria vindo muito antes".

O que o Dr. faz √© ir direto na raiz do problema e montar um plano espec√≠fico pro seu caso. Isso acaba evitando meses de sofrimento e tentativas que s√≥ adiam a solu√ß√£o.

Posso ver aqui o melhor hor√°rio para voc√™... Pode ser essa semana ainda ou prefere aguardar mais uns dias? üìÖ`;
        } else {
          reply = `√â t√£o bom quando conseguimos voltar √† rotina com tranquilidade, n√© ${session.firstName}? O Dr. Quelson √© especialista exatamente nisso que voc√™ est√° passando. Que tal agendarmos uma conversa com ele? üòä`;
        }
        break;

      default:
        // Respostas para situa√ß√µes especiais
        if (intent === 'convenio') {
          reply = `${session.firstName}, aqui √© particular, mas posso te dizer uma coisa? Muita gente que vem aqui j√° passou por v√°rios m√©dicos do conv√™nio... e depois fala que valeu cada centavo investir numa consulta onde realmente se sentiram ouvidas. Quer que eu te conte como funciona? üòä`;
        } else if (intent === 'urgencia') {
          reply = `${session.firstName}, entendo sua urg√™ncia! Para eu conseguir te ajudar da melhor forma, pode me contar rapidinho o que est√° acontecendo? üôè`;
        } else {
          reply = `${session.firstName}, estou aqui para te ajudar da melhor forma. Pode me contar o que voc√™ precisa? üí¨`;
        }
    }

    // Adiciona resposta ao hist√≥rico antes de retornar
    session.conversationHistory.push(`Bot: ${reply}`);
    return reply;

  } catch (error) {
    console.error('üö® Erro cr√≠tico na gera√ß√£o de resposta:', error);
    
    // Fallback de emerg√™ncia
    const safeName = session.firstName || 'amigo(a)';
    return `Desculpe, ${safeName}, estou com dificuldades t√©cnicas moment√¢neas. Por favor, ligue para (11) 99999-9999 para agendamento direto. Obrigada pela compreens√£o! üòä`;
  }
}

// ---- VALIDA√á√ÉO DE PAYLOAD ---------------------------------------------------
function validateWebhookPayload(body) {
  if (!body || typeof body !== 'object') {
    throw new Error('Payload inv√°lido: body n√£o √© objeto');
  }
  
  if (!body.entry || !Array.isArray(body.entry)) {
    throw new Error('Payload inv√°lido: entry n√£o √© array');
  }
  
  return true;
}

// ---- ENVIO DE MENSAGEM BLINDADO - CORRIGIDO ---------------------------------
async function sendMessage(to, message, retries = 3) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const response = await fetch(`https://graph.facebook.com/v19.0/${process.env.WHATSAPP_PHONE_ID}/messages`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.WHATSAPP_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messaging_product: 'whatsapp',
          to: to,
          text: { body: message },
        }),
      });

      if (response.ok) {
        return true;
      } else {
        const errorData = await response.text();
        console.error(`‚ùå Tentativa ${attempt}/${retries} falhou:`, errorData);
        
        // Se √© erro de token ou permiss√£o, n√£o tenta novamente
        if (errorData.includes('OAuthException') || 
            errorData.includes('access token') || 
            errorData.includes('does not have permission') ||
            errorData.includes('code":10')) {
          console.error('üö® ERRO DE TOKEN/PERMISS√ÉO - Verificar configura√ß√µes Meta');
          console.error('üí° Solu√ß√µes:');
          console.error('   1. Gerar novo token no Meta for Developers');
          console.error('   2. Verificar permiss√µes whatsapp_business_messaging');
          console.error('   3. Confirmar Phone Number ID: ' + process.env.WHATSAPP_PHONE_ID);
          throw new Error(`Token/Permiss√£o inv√°lida: ${errorData}`);
        }
        
        if (attempt === retries) {
          throw new Error(`Falha ap√≥s ${retries} tentativas: ${errorData}`);
        }
        
        // Wait before retry (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt - 1)));
      }
    } catch (error) {
      console.error(`‚ùå Erro na tentativa ${attempt}/${retries}:`, error.message);
      
      if (attempt === retries) {
        throw error;
      }
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt - 1)));
    }
  }
  
  return false; // CORRE√á√ÉO: Retorna false se todas as tentativas falharem
}

// ---- LOGGING CR√çTICO --------------------------------------------------------
function logCriticalError(error, context) {
  const errorLog = {
    timestamp: new Date().toISOString(),
    error: error.message,
    stack: error.stack,
    context,
    severity: 'CRITICAL',
    dailyTokens: dailyTokenCount,
    dailyRequests: dailyRequestCount,
    activeSessions: sessions.size
  };
  
  console.error('üö® ERRO CR√çTICO:', JSON.stringify(errorLog, null, 2));
  
  // Em produ√ß√£o: enviar para sistema de monitoramento
  // sendToSlack(errorLog) ou sendToEmail(errorLog)
}

// ---- WEBHOOK BLINDADO CONTRA TODOS OS ERROS ---------------------------------
app.post('/webhook', async (req, res) => {
  const startTime = Date.now();
  let from = 'unknown';
  
  try {
    // 1. VALIDA√á√ÉO DE PAYLOAD
    validateWebhookPayload(req.body);
    
    console.log('üì® Webhook recebido:', JSON.stringify(req.body, null, 2));
    
    const entry = req.body.entry?.[0];
    const changes = entry?.changes?.[0];
    const messageData = changes?.value?.messages?.[0];

    // 2. FILTROS DE MENSAGEM
    if (!messageData) {
      console.log('‚ÑπÔ∏è Webhook sem mensagem, ignorando');
      return res.sendStatus(200);
    }

    // Extrai dados b√°sicos
    from = messageData.from;
    const messageType = messageData.type;
    
    // 3. RATE LIMITING POR USU√ÅRIO
    if (isRateLimited(from)) {
      console.log(`‚ö†Ô∏è Rate limit atingido para ${from}`);
      await sendMessage(from, 'Por favor, aguarde um momento antes de enviar outra mensagem. Obrigada! üòä');
      return res.status(429).send('Rate limited');
    }

    // 4. CONTROLE DE TIPOS DE M√çDIA
    if (messageType !== 'text') {
      console.log(`üìé M√≠dia recebida (${messageType}) de ${from}`);
      const session = getSession(from);
      const mediaResponse = `${session.firstName || 'Ol√°'}, recebi sua ${messageType === 'audio' ? 'mensagem de √°udio' : 'm√≠dia'}! 
      
Por favor, pode escrever em texto? Assim consigo te atender melhor! üòä

Para emerg√™ncias, ligue:
üöë SAMU: 192
üìû Consult√≥rio: (11) 99999-9999`;
      
      await sendMessage(from, mediaResponse);
      return res.sendStatus(200);
    }

    const text = messageData.text?.body;
    
    if (!text || text.trim().length === 0) {
      console.log('‚ÑπÔ∏è Mensagem de texto vazia, ignorando');
      return res.sendStatus(200);
    }

    console.log(`[${new Date().toLocaleTimeString()}] üìû ${from}: ${text}`);

    // 5. CONTROLE DE SESS√ÉO COM REDIS
    const session = await getSession(from);
    session.requestCount = (session.requestCount || 0) + 1;

    // Previne spam de um usu√°rio
    if (session.requestCount > 100) {
      console.log(`üö´ Usu√°rio ${from} excedeu limite de mensagens`);
      await sendMessage(from, 'Por hoje j√° conversamos bastante! Para continuar, ligue para (11) 99999-9999. Obrigada! üòä');
      return res.sendStatus(200);
    }

    // 6. DETEC√á√ÉO DE EMERG√äNCIA (prioridade m√°xima)
    if (isEmergency(text) && !emergencyPhones.has(from)) {
      console.log(`üö® EMERG√äNCIA detectada de ${from}: ${text}`);
      const emergencyReply = getEmergencyResponse(session.firstName);
      await sendMessage(from, emergencyReply);
      emergencyPhones.add(from);
      
      // Log especial para emerg√™ncias
      const emergencyLog = {
        timestamp: new Date().toISOString(),
        phone: from,
        message: text,
        type: 'EMERGENCY',
        firstName: session.firstName
      };
      console.error('üö® EMERG√äNCIA M√âDICA:', JSON.stringify(emergencyLog));
      
      return res.sendStatus(200);
    }

    // 7. GERA√á√ÉO DE RESPOSTA PRINCIPAL
    const reply = await generateReply(session, from, text);
    
    // IMPORTANTE: Salva session ap√≥s modifica√ß√µes
    await saveSession(from, session);
    
    console.log(`[${new Date().toLocaleTimeString()}] ü§ñ ‚Üí ${session.firstName || from}: ${reply.substring(0, 100)}${reply.length > 100 ? '...' : ''}`);

    // 8. ENVIO COM RETRY
    await sendMessage(from, reply);

    // 9. M√âTRICAS DE PERFORMANCE
    const processingTime = Date.now() - startTime;
    if (processingTime > 5000) {
      console.warn(`‚ö†Ô∏è Processamento lento: ${processingTime}ms para ${from}`);
    }

    res.sendStatus(200);

  } catch (error) {
    // 10. TRATAMENTO DE ERRO CR√çTICO
    logCriticalError(error, {
      body: req.body,
      from,
      dailyTokens: dailyTokenCount,
      dailyRequests: dailyRequestCount,
      processingTime: Date.now() - startTime
    });

    // Fallback graceful melhorado
    try {
      // Se for erro de token, n√£o tenta enviar fallback
      if (error.message.includes('Token') || error.message.includes('permiss')) {
        console.error('üíÄ Erro de token - n√£o enviando fallback para evitar loop');
        return res.status(500).json({
          error: 'WhatsApp token/permission error',
          message: 'Verificar configura√ß√µes no Meta for Developers',
          timestamp: new Date().toISOString(),
          reference: `ERR-TOKEN-${Date.now()}`
        });
      }
      
      const session = getSession(from);
      const fallbackMessage = `Desculpe, ${session.firstName || 'amigo(a)'}, estou com dificuldades t√©cnicas. 

Para agendamento imediato:
üìû Ligue: (11) 99999-9999
‚è∞ Seg-Sex: 8h √†s 18h
‚è∞ S√°b: 8h √†s 12h

Obrigada pela compreens√£o! üòä`;
      
      await sendMessage(from, fallbackMessage);
    } catch (fallbackError) {
      console.error('üíÄ Falha total no fallback:', fallbackError);
    }

    res.status(500).json({
      error: 'Internal server error',
      timestamp: new Date().toISOString(),
      reference: `ERR-${Date.now()}`
    });
  }
});

// ---- VALIDA√á√ÉO DO WEBHOOK (GET) ---------------------------------------------
app.get('/webhook', (req, res) => {
  const VERIFY_TOKEN = process.env.VERIFY_TOKEN;
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  console.log(`üîê Verifica√ß√£o webhook: mode=${mode}, token=${token ? 'PROVIDED' : 'MISSING'}`);

  if (mode === 'subscribe' && token === VERIFY_TOKEN) {
    console.log('‚úÖ Webhook verificado com sucesso!');
    return res.status(200).send(challenge);
  } else {
    console.log('‚ùå Falha na verifica√ß√£o do webhook');
    return res.sendStatus(403);
  }
});

// ---- ROTA DE STATUS E MONITORAMENTO -----------------------------------------
app.get('/', (req, res) => {
  const uptime = process.uptime();
  const memoryUsage = process.memoryUsage();
  
  res.json({
    status: 'üíº Secret√°ria NEPQ com Redis Persistente',
    version: '3.0.0-redis',
    storage: sessionManager.fallbackToMemory ? 'memory' : 'redis',
    uptime: `${Math.floor(uptime / 3600)}h ${Math.floor((uptime % 3600) / 60)}m`,
    memory: {
      used: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
      total: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`
    },
    metrics: {
      activeSessions: (await sessionManager.getStats()).activeSessions,
      dailyTokens: dailyTokenCount,
      dailyRequests: dailyRequestCount,
      hourlyTokens: hourlyTokenCount,
      hourlyRequests: hourlyRequestCount,
      maxDailyTokens: MAX_DAILY_TOKENS,
      maxDailyRequests: MAX_DAILY_REQUESTS,
      maxHourlyTokens: MAX_HOURLY_TOKENS,
      maxHourlyRequests: MAX_HOURLY_REQUESTS,
      emergencyPhonesSize: emergencyPhones.size
    },
    features: [
      'üö® Detec√ß√£o de emerg√™ncia melhorada',
      '‚ö° Rate limiting com Redis',
      'üß† Context compression inteligente',
      'üí∞ Cost monitoring rigoroso',
      'üîÑ Auto-retry com backoff',
      'üõ°Ô∏è Error recovery robusto',
      'üßπ Cleanup autom√°tico Redis/Memory',
      'üìä Real-time metrics',
      'üïê Timezone Brasil correto',
      'üíæ Sessions persistentes com Redis',
      'üîÑ Fallback graceful para memory'
    ],
    timestamp: new Date().toISOString()
  });
});

// ---- ROTA DE M√âTRICAS PARA MONITORAMENTO ------------------------------------
app.get('/metrics', async (req, res) => {
  const stats = await sessionManager.getStats();
  
  res.json({
    sessions: {
      active: stats.activeSessions,
      storage: stats.storage,
      redis: stats.redis
    },
    usage: {
      dailyTokens: dailyTokenCount,
      dailyRequests: dailyRequestCount,
      hourlyTokens: hourlyTokenCount,
      hourlyRequests: hourlyRequestCount,
      tokenLimit: MAX_DAILY_TOKENS,
      requestLimit: MAX_DAILY_REQUESTS,
      tokenPercentage: ((dailyTokenCount / MAX_DAILY_TOKENS) * 100).toFixed(1),
      requestPercentage: ((dailyRequestCount / MAX_DAILY_REQUESTS) * 100).toFixed(1)
    },
    rateLimiting: {
      activeUsers: stats.activeRateLimits || 0,
      emergencyPhones: emergencyPhones.size
    },
    system: {
      uptime: process.uptime(),
      memoryUsage: process.memoryUsage(),
      nodeVersion: process.version
    }
  });
});

// ---- ROTA DE RESET (PARA EMERG√äNCIAS) ---------------------------------------
app.post('/reset', (req, res) => {
  const { password } = req.body;
  
  if (password !== process.env.RESET_PASSWORD) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  // Reset completo do sistema
  emergencyPhones.clear();
  dailyTokenCount = 0;
  dailyRequestCount = 0;
  hourlyTokenCount = 0;
  hourlyRequestCount = 0;
  
  // Reset Redis sessions se dispon√≠vel
  try {
    if (!sessionManager.fallbackToMemory) {
      const keys = await sessionManager.client.keys('session:*');
      if (keys.length > 0) {
        await sessionManager.client.del(keys);
        console.log(`üîÑ ${keys.length} sessions Redis removidas`);
      }
    } else {
      sessionManager.memoryCache.clear();
      sessionManager.memoryRateLimit.clear();
      console.log('üîÑ Memory cache limpo');
    }
  } catch (error) {
    console.error('‚ö†Ô∏è Erro no reset Redis:', error.message);
  }
  
  console.log('üîÑ Sistema resetado manualmente');
  
  res.json({
    message: 'Sistema resetado com sucesso',
    timestamp: new Date().toISOString()
  });
});

// ---- HEALTH CHECK -----------------------------------------------------------
app.get('/health', (req, res) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    checks: {
      openai: process.env.OPENAI_API_KEY ? 'configured' : 'missing',
      whatsapp: process.env.WHATSAPP_TOKEN ? 'configured' : 'missing',
      whatsappPhoneId: process.env.WHATSAPP_PHONE_ID ? 'configured' : 'missing',
      verifyToken: process.env.VERIFY_TOKEN ? 'configured' : 'missing',
      memory: process.memoryUsage().heapUsed < 500 * 1024 * 1024 ? 'ok' : 'high',
      sessions: sessions.size < 1000 ? 'ok' : 'high'
    }
  };
  
  const allHealthy = Object.values(health.checks).every(check => 
    check === 'configured' || check === 'ok'
  );
  
  res.status(allHealthy ? 200 : 503).json(health);
});

// ---- CLEANUP JOBS MELHORADOS COM REDIS -------------------------------------
// Limpeza de sess√µes antigas a cada 30 minutos
setInterval(async () => {
  await cleanupOldSessions();
}, 30 * 60 * 1000);

// Limpeza de emergencyPhones a cada 1 hora
setInterval(() => {
  const size = emergencyPhones.size;
  emergencyPhones.clear();
  if (size > 0) {
    console.log(`üßπ Emergency phones: ${size} registros limpos`);
  }
}, 60 * 60 * 1000);

// Limpeza de mem√≥ria for√ßada a cada 6 horas
setInterval(() => {
  if (global.gc) {
    global.gc();
    console.log('üßπ Garbage collection manual executada');
  }
}, 6 * 60 * 60 * 1000);()) {
    const recentRequests = requests.filter(time => now - time < 60000);
    if (recentRequests.length === 0) {
      rateLimiter.delete(phone);
      cleaned++;
    } else {
      rateLimiter.set(phone, recentRequests);
    }
  }
  
  if (cleaned > 0) {
    console.log(`üßπ Rate limiter: ${cleaned} usu√°rios inativos removidos`);
  }
}, 5 * 60 * 1000);

// Limpeza de emergencyPhones a cada 1 hora
setInterval(() => {
  const size = emergencyPhones.size;
  emergencyPhones.clear();
  if (size > 0) {
    console.log(`üßπ Emergency phones: ${size} registros limpos`);
  }
}, 60 * 60 * 1000);

// NOVO: Limpeza de mem√≥ria for√ßada a cada 6 horas
setInterval(() => {
  if (global.gc) {
    global.gc();
    console.log('üßπ Garbage collection manual executada');
  }
}, 6 * 60 * 60 * 1000);

// ---- GRACEFUL SHUTDOWN COM REDIS --------------------------------------------
process.on('SIGTERM', async () => {
  console.log('üì¥ Recebido SIGTERM, fazendo shutdown graceful...');
  
  // Log final
  const stats = await sessionManager.getStats();
  console.log(`üìä Stats finais: ${stats.activeSessions} sess√µes, ${dailyTokenCount} tokens, ${dailyRequestCount} requests`);
  
  // Fecha conex√£o Redis
  await sessionManager.close();
  
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('üì¥ Recebido SIGINT, fazendo shutdown graceful...');
  await sessionManager.close();
  process.exit(0);
});

// ---- INICIALIZA√á√ÉO -----------------------------------------------------------
const PORT = process.env.PORT || 3000;

app.listen(PORT, async () => {
  console.log('üöÄüíæ === SECRET√ÅRIA NEPQ COM REDIS PERSISTENTE === üíæüöÄ');
  console.log(`üìç Porta: ${PORT}`);
  console.log(`üß† M√©todo: Neuro Emotional Persuasion Questions`);
  console.log(`‚öïÔ∏è Especialidade: Dr. Quelson - Gastroenterologia`);
  console.log(`üîó Webhook: https://meu-bot-jhcl.onrender.com/webhook`);
  console.log('');
  
  // Status do Redis
  const stats = await sessionManager.getStats();
  console.log('üíæ ARMAZENAMENTO:');
  console.log(`  üìä Storage: ${stats.storage}`);
  console.log(`  üíæ Redis: ${stats.redis ? 'Conectado' : 'Desconectado'}`);
  console.log(`  üìà Sessions: ${stats.activeSessions} ativas`);
  console.log('');
  
  console.log('üõ°Ô∏è PROTE√á√ïES ATIVAS:');
  console.log('  ‚úÖ Sessions persistentes com Redis + fallback');
  console.log('  ‚úÖ Rate limiting distribu√≠do');
  console.log('  ‚úÖ Detec√ß√£o de emerg√™ncia m√©dica melhorada');
  console.log('  ‚úÖ Controle de custos OpenAI rigoroso');
  console.log('  ‚úÖ Context compression inteligente');
  console.log('  ‚úÖ Fallback sem IA robusto');
  console.log('  ‚úÖ Retry autom√°tico com exponential backoff');
  console.log('  ‚úÖ Timezone Brasil correto');
  console.log('  ‚úÖ Valida√ß√£o de payload completa');
  console.log('  ‚úÖ Graceful error handling');
  console.log('  ‚úÖ Auto-cleanup Redis/Memory');
  console.log('');
  console.log(`üí∞ Limites: ${MAX_DAILY_TOKENS} tokens/dia, ${MAX_DAILY_REQUESTS} requests/dia`);
  console.log(`‚è∞ Limites hor√°rios: ${MAX_HOURLY_TOKENS} tokens/hora, ${MAX_HOURLY_REQUESTS} requests/hora`);
  console.log('üìä Monitoramento: /metrics');
  console.log('üè• Health check: /health');
  console.log('');
  console.log('üíº Pronta para atender pacientes com persist√™ncia total!');
  console.log('üîÑ Conversas sobrevivem a restarts e deploys!');
});
